import ROOT
import pickle
import os, sys, time
import struct

ROOT.gROOT.SetBatch(True)

# TIGER_scripts, lib/GEM_ANALYSIS_classes.py::1557
def convert_to_fC(sigma, VcaspVth):
  gain = 12.25
  return (VcaspVth * -0.621 + 39.224) / gain * sigma

# Q = p0 + p1 * eFine
def get_linear_fit(saturation_value, vcasp, thr, maximum_efine, baseline_thr):
  p0 = saturation_value
  q2 = convert_to_fC(baseline_thr - thr, vcasp)
  p1 = (q2 - saturation_value) / maximum_efine
  return (p0, p1)
  
def calib(run_number):
  run_number = int(sys.argv[1])
  run_folder = f'../data/tiger/RUN_{run_number}'
  fin = open(f'{run_folder}/CONF_run_{run_number}.pkl', 'rb')
  run_parameters = pickle.load(fin)
  fin.close()

  channels_good = {}
  channels_bad = {}
  channels_disabled = {}
  
  for gr in range(20):
    if f'GEMROC {gr}' not in run_parameters.keys():
      continue
    run_parameters_gr = run_parameters[f'GEMROC {gr}']
    t = ROOT.TChain('tigerTL', 'tigerTL')
    t.Add(f'{run_folder}/SubRUN_*_GEMROC_{gr}_TL.root')
    t.Draw('eFine:tigerID*64+channelID >> h(512, 0, 512, 1008, 0, 1008)', '', 'colz')
    h = ROOT.gDirectory.Get('h')
    for tiger in range(8):
      print(f'Scanning gemroc {gr} tiger {tiger}')
      thrs_t = [] # baseline -- maximum value on thr scan plot
      with open(f'{run_folder}/thr/GEMROC{gr}_Chip{tiger}_T.thr', 'r') as fin:
        for l in fin:
          thrs_t.append(list(map(lambda x: float(x.strip()), l.split()))[2])
      run_parameters_t = run_parameters_gr[f'TIGER {tiger}']
      vcasp = run_parameters_t['Global']['Vcasp_Vth']
      for channel in range(64):
        saturation_value = 45.0
        thr = run_parameters_t[f'Ch {channel}']['Vth_T1']
        enabled = run_parameters_t[f'Ch {channel}']['TriggerMode'] != 3
        if not enabled:
          channels_disabled[(gr, tiger, channel)] = saturation_value
          continue
        if run_parameters_t[f'Ch {channel}']['TriggerMode'] != 0:
          v = run_parameters_t[f'Ch {channel}']['TriggerMode']
          print(f'Strange TriggerMode: {v}')
        hist_efine = h.ProjectionY(f'h_{gr}_{tiger}_{channel}', channel+tiger*64+1, channel+tiger*64+1)
        # hist_efine.Print()
        maximum = int(hist_efine.GetMaximum())
        min_limit = int(maximum * 0.003)
        min_limit = min_limit if min_limit > 1 else 2
        max_bin_n = hist_efine.FindLastBinAbove(min_limit)
        maximum_efine = int(hist_efine.GetXaxis().GetBinCenter(max_bin_n))
        if maximum_efine > 0:
          channels_good[(gr, tiger, channel)] = (saturation_value, vcasp, thrs_t[channel], thr, maximum_efine)
        else:
          channels_bad[(gr, tiger, channel)] = (saturation_value, vcasp, thrs_t[channel], thr)
        # maximum_efine = maximum_efine if maximum_efine > 0 else 1007        

        
    # print(run_parameters['GEMROC 0']['TIGER 0']['Ch 0'].keys())

  fout = open(f'../out/tiger_efine_calibration_SH_run{run_number}.txt', 'w')
  foutbin = open(f'../out/tiger_efine_calibration_SH_run{run_number}-bin.bin', 'wb')
  print(f'# Generated by run {run_number}', file=fout)
  print('# Q =  p0 + p1 \cdot eFine', file=fout)
  print('# gemroc tiger channel p0 p1', file=fout)

  fits = {}
  for k,v in channels_good.items():
    gr, tiger, channel = k
    saturation_value, vcasp, baseline_thr, thr, maximum_efine = v
    p0, p1 = get_linear_fit(saturation_value, vcasp, thr, maximum_efine, baseline_thr)
    fits[k] = (p0, p1)
    # Estimate as linear function p[0] + p[1]*x        
    print(f'{gr} {tiger} {channel} {saturation_value} {vcasp} {baseline_thr} {thr} {maximum_efine} -> {p0}, {p1}')
    print(f'{gr} {tiger} {channel} {p0}, {p1}', file=fout)
    foutbin.write(struct.pack('h', gr))
    foutbin.write(struct.pack('h', tiger))
    foutbin.write(struct.pack('h', channel))
    foutbin.write(struct.pack('d', p0))
    foutbin.write(struct.pack('d', p1))

  print('# Enabled channels with no signal or signals overfull eFine range', file=fout)
  for k,v in channels_bad.items():
    gr, tiger, channel = k
    saturation_value, vcasp, baseline_thr, thr = v
    maximum_efine = 1007
    p0, p1 = get_linear_fit(saturation_value, vcasp, thr, maximum_efine, baseline_thr)
    # Estimate as linear function p[0] + p[1]*x        
    print(f'{gr} {tiger} {channel} b{vcasp} {baseline_thr} {thr} {maximum_efine} -> {p0}, {p1}')
    print(f'{gr} {tiger} {channel} {p0}, {p1}', file=fout)
    foutbin.write(struct.pack('h', gr))
    foutbin.write(struct.pack('h', tiger))
    foutbin.write(struct.pack('h', channel))
    foutbin.write(struct.pack('d', p0))
    foutbin.write(struct.pack('d', p1))

  print('# Disabled channels -- mean values are used', file=fout)
  mean_p0_p1_ratio = sum([p0 / p1 for (_, (p0, p1)) in fits.items()]) / len(fits)
  for k,v in channels_disabled.items():
    gr, tiger, channel = k
    p0 = v
    p1 = p0 / mean_p0_p1_ratio
    print(f'{gr} {tiger} {channel} (disabled) -> {p0}, {p1}')
    print(f'{gr} {tiger} {channel} {p0}, {p1}', file=fout)
    foutbin.write(struct.pack('h', gr))
    foutbin.write(struct.pack('h', tiger))
    foutbin.write(struct.pack('h', channel))
    foutbin.write(struct.pack('d', p0))
    foutbin.write(struct.pack('d', p1))

  fout.close()
  foutbin.close()

if __name__ == '__main__':
  calib(int(sys.argv[1]))
